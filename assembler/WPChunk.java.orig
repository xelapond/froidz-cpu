import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.List;
import java.util.HashMap;

/**
 * Represents one assembly operation
 * There is one WPChunk for every operation in the AVR Assembly Definition
 * 
 * @author Jacob Weiss,Alex Teiche 
 * @version 0.0.1
 */
public class WPChunk
{   
    private String opName;
    private String[] operands;
    private String[] ranges;
    private String opCode;
    
    private Pattern opCodePattern;
    
    public WPChunk(String line)
    {
        line = line.replace(" ", "");
        String[] parts = line.split("\\|");
        this.opName = parts[0];
        this.operands = parts[1].split(",");
        this.ranges = parts[2].split(",");
        this.opCode = parts[3];
        
        this.opCodePattern = Pattern.compile(this.formatRegex(this.opCode));
    }
    
    /**
     * Takes an opCode including data directly from an assembled program, and determines if it matches this operation
     * @param opCode The opCode including data
     * @return true -> It matched
     */
    public boolean match(String opCode)
    {
        return this.opCodePattern.matcher(opCode).matches();
    }
    
    /**
     * generateInstruction()
     * 
     * PRECONDITION: 
     * 
     * argX is a string representation of a hex value
     * @param List<String> (name, arg0, arg1, ... , argN)
     */
    public String generateInstruction(List<String> asm)
    {
<<<<<<< HEAD
        /*
        // Check to make sure that the number of arguments to this method equals
        // the number of operands that this operation takes.
=======
        for (String s : asm)
        {
            System.out.print(s + " ");
        }
        System.out.println();
        
>>>>>>> 81bcbbd590aa7827ede3ea9b989969b4f0f0dae9
        if (!asm.get(0).equals(this.opName) || asm.size() - 1 != operands.length)
        {
            System.out.println("invalid input");
            return null;
        }
        
        String instruction = this.opCode;
        for (int op = 0; op < operands.length; op++)
        {
            String operand = this.operands[op].split("=")[1]; // Template of input
            String asmInput = asm.get(op + 1);  // Instuction operand
            for (int i = 0; i < operand.length() - offset; i++)
            {
                instruction = instruction.replaceAll(operand.charAt(i + offset) + "", asmInput.charAt(i) + "");
            }
        }
        
        return instruction;
<<<<<<< HEAD
        */
       return null;
=======
    }
    
    public String numberToBinary(String num)
    {
        if (num.substring(0, 2).equals("0x"))
        {
            System.out.println("hello");
            String binary = "";
            for (int i = 2; i < num.length(); i++)
            {
                binary += WPChunk.hexConverter.get(num.substring(i, i+1));
            }
            return binary;
        }
        else if (num.substring(0, 2).equals("0b"))
        {
            return num.substring(2);
        }
        else
        {
            if (num.substring(0,1).equalsIgnoreCase("r"))
            {
                num = num.substring(1);
            }
            return Integer.toBinaryString(Integer.parseInt(num));
        }
>>>>>>> 81bcbbd590aa7827ede3ea9b989969b4f0f0dae9
    }
    
    /**
     * Takes an opcode and replaces all ascii characters with . to match a single character
     * @param opCode An opCode String
     * @return A string representing a regex to match only the static parts of the opcode
     */
    private String formatRegex(String opCode)
    {
        return opCode.replaceAll("[a-z]", ".");
    } 
    
    // Public Getter Methods
    public String getOpName()
    {
        return this.opName;
    }
    
    public String[] getOperands()
    {
        return this.operands;
    }
    
    public String[] getRanges()
    {
        return this.ranges;
    }
    
    public String getOpCode()
    {
        return this.opCode;
    }
}
